% -----------------------------------------------
% Template for SMC 2020
% adapted from previous SMC paper templates
% -----------------------------------------------

\documentclass{article}
\usepackage{smc2020}
\usepackage{times}
\usepackage{ifpdf}
\usepackage[english]{babel}
\usepackage{cite}
\usepackage{amsmath}
\usepackage{tabularx}
\usepackage{listings}
\usepackage{footmisc}
\usepackage{tikz}
\usetikzlibrary{positioning}

%%%%%%%%%%%%%%%%%%%%%%%% Some useful packages %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%% See related documentation %%%%%%%%%%%%%%%%%%%%%%%%%%
%\usepackage{amsmath} % popular packages from Am. Math. Soc. Please use the 
%\usepackage{amssymb} % related math environments (split, subequation, cases,
%\usepackage{amsfonts}% multline, etc.)
%\usepackage{bm}      % Bold Math package, defines the command \bf{}
%\usepackage{paralist}% extended list environments
%%subfig.sty is the modern replacement for subfigure.sty. However, subfig.sty 
%%requires and automatically loads caption.sty which overrides class handling 
%%of captions. To prevent this problem, preload caption.sty with caption=false 
%\usepackage[caption=false]{caption}
%\usepackage[font=footnotesize]{subfig}


%user defined variables
\def\papertitle{Applied Physical Modeling for Sound Synthesis: The Yaybahar}
\def\firstauthor{Pelle Juul Christensen}
\def\secondauthor{Silvin Willemsen}
\def\thirdauthor{Stefania Serafin}

% adds the automatic
% Saves a lot of output space in PDF... after conversion with the distiller
% Delete if you cannot get PS fonts working on your system.

% pdf-tex settings: detect automatically if run by latex or pdflatex
\newif\ifpdf
\ifx\pdfoutput\relax
\else
   \ifcase\pdfoutput
      \pdffalse
   \else
      \pdftrue
\fi

\ifpdf % compiling with pdflatex
  \usepackage[pdftex,
    pdftitle={Applied Physical Modeling for Sound Synthesis: The Yaybahar},
    pdfauthor={\firstauthor, \secondauthor, \thirdauthor},
    bookmarksnumbered, % use section numbers with bookmarks
    pdfstartview=XYZ % start with zoom=100% instead of full screen; 
                     % especially useful if working with a big screen :-)
   ]{hyperref}
  %\pdfcompresslevel=9

  \usepackage[pdftex]{graphicx}
  % declare the path(s) where your graphic files are and their extensions so 
  %you won't have to specify these with every instance of \includegraphics
  \graphicspath{{./figures/}}
  \DeclareGraphicsExtensions{.pdf,.jpeg,.png}

  \usepackage[figure,table]{hypcap}

\else % compiling with latex
  \usepackage[dvips,
    bookmarksnumbered, % use section numbers with bookmarks
    pdfstartview=XYZ % start with zoom=100% instead of full screen
  ]{hyperref}  % hyperrefs are active in the pdf file after conversion

  \usepackage[dvips]{epsfig,graphicx}
  % declare the path(s) where your graphic files are and their extensions so 
  %you won't have to specify these with every instance of \includegraphics
  \graphicspath{{./figures/}}
  \DeclareGraphicsExtensions{.eps}

  \usepackage[figure,table]{hypcap}
\fi

%setup the hyperref package - make the links black without a surrounding frame
\hypersetup{
    colorlinks,%
    citecolor=black,%
    filecolor=black,%
    linkcolor=black,%
    urlcolor=black
}


% Title.
% ------
\title{\papertitle}

% Authors
% Please note that submissions are NOT anonymous, therefore 
% authors' names have to be VISIBLE in your manuscript. 
%
% Single address
% To use with only one author or several with the same address
% ---------------
%\oneauthor
%  {\firstauthor} {Sound and Music Computing, Aalborg University, Copenhagen \\ %
%    {\tt \href{mailto:pjch17@student.aau.dk}{pjch17@student.aau.dk}}}

%Two addresses
%--------------
% \twoauthors
%   {\firstauthor} {Affiliation1 \\ %
%     {\tt \href{mailto:author1@smcnetwork.org}{author1@smcnetwork.org}}}
%   {\secondauthor} {Affiliation2 \\ %
%     {\tt \href{mailto:author2@smcnetwork.org}{author2@smcnetwork.org}}}

% Three addresses
% --------------
  \threeauthors
    {\firstauthor} {Aalborg University Copenhagen \\ %
      {\tt \href{mailto:pjch17@student.aau.dk}{pjch17@student.aau.dk}}}
    {\secondauthor} {Multisensory Experience Lab, CREATE\\
    Aalborg University Copenhagen \\%
      {\tt \href{mailto:sil@create.aau.dk}{sil@create.aau.dk}}}
    {\thirdauthor} {Multisensory Experience Lab, CREATE\\ Aalborg University Copenhagen \\ %
      {\tt \href{mailto:sts@create.aau.dk}{sts@create.aau.dk}}}


% ***************************************** the document starts here ***************
\begin{document}
%
\capstartfalse
\maketitle
\capstarttrue
%
\begin{abstract}
In this paper, finite difference schemes (FDSs) are adopted to model a specific instrument, the Yaybahar, invented by Turkish artist Görkem Şen.
Each part of the instrument is simulated independently and its physical behavior is explained in an intuitive yet accurate manner. 
The models are implemented in C++ to form an interactive, real-time application, whose architecture and optimization are discussed.
Code and sound samples are available online.
\end{abstract}
%

\section{Introduction}\label{sec:introduction}
\nocite{Someone:00}

The Yaybahar is a novel acoustical instrument invented by Turkish artist Görkem Şen. It consists of a string connected to two springs that connect to two drum heads as seen in Figure \ref{fig:yaybahar}.
The instrument is played by bowing the string and striking the springs and drums using a mallet.
The combination of the springs and the drums create a grand, reverberant sound that is unusual for acoustical instruments.
A video of Görkem Şen playing the Yaybahar can be viewed on YouTube\footnote{\url{https://youtu.be/_aY6TxC1ojA}\label{fn:videoUrl}}.

\begin{figure}[h]
    \centering
    \includegraphics[width=\linewidth]{yaybahar.jpg}
    \caption{A screenshot of a video\footref{fn:videoUrl} 
    of Görkem Şen playing the Yaybahar by bowing the string.}
    \label{fig:yaybahar}
\end{figure}

This paper presents a real-time sound synthesis algorithm that mimics the Yaybahar by modeling its physical behaviour.
Several physical modeling techniques exist, such as digital waveguides \cite{smith1992physical} and modal synthesis \cite{morrison1993mosaic}. Those techniques result in efficient high quality sounds, but do not directly solve a mathematical formulation.

Finite difference (FD) methods on the other hand -- first used in a sound synthesis context by Hiller and Ruiz \cite{Hiller1971} -- are general and flexible and allow a proper numerical simulation of the instrument.
The application of finite difference schemes (FDSs) to sound synthesis is quite mature and a lot of the basic theory can be found in the seminal work by Stefan Bilbao \textit{Numerical Methods for Sound Synthesis}\cite{bilbao_numerical_2009}, on which most of the theory in this paper is based.

Despite their maturity, FDSs have not been readily applied to real-time synthesis, probably because they are quite computationally heavy, especially considering accurate simulations of nonlinear systems.
One example of a real-time FDS implementation can be found in \cite{willemsen_real-time_2019}, which also covers expressive real-time interaction with the model.

We begin our efforts to simulate the Yaybahar in Section \ref{sec:finiteDifferenceSchemes}, where we briefly review the basic concepts of FDSs.
In Section \ref{sec:elements}, we examine all the elements of the instrument, show how they can be modeled, discuss their physics, and show how they can be implemented using FDSs.
Then, in Section \ref{sec:implementation}, we give an overview of the architecture of the C++ application that implements the synthesis algorithm and cover the optimizations that were needed to get everything running in real-time.
Lastly, we conclude in Section \ref{sec:conclusion}.

\section{Finite Difference Schemes}
\label{sec:finiteDifferenceSchemes}

In this section we provide a gentle and short introduction to FDSs. For those not familiar with the topic a more in depth description can be found in \cite{bilbao_numerical_2009}.
FDSs are used to numerically solve differential equations by approximating derivatives. A first order derivative, for example, can be approximated using
\begin{equation}
  \frac{d}{dx} f(x) \approx \frac{f(x + h) - f(x)}{h},
\end{equation}
where $h$ is the spacing between two values of $f$. As $h$ becomes smaller, this approximation gets more precise and in the limit where $h\rightarrow 0$ it is exactly the definition of the first order derivative.

If $u = u(t)$ is a function of time, we now introduce the notation $u^n = u(nk)$, where $n$ is the current time step and $k = 1/f_\text{s}$ is the sampling period given the sampling rate $f_\text{s}$.
We can now write our derivative approximation as
\begin{equation}
  \frac{d}{dt} u \approx \frac{1}{k} (u^{n+1} - u^{n}).
\end{equation}
For terseness and notational purposes, we introduce the following notation:
\begin{equation}
  \label{eq:dtf}
  \delta_{t+} u^n = \frac{1}{k} (u^{n+1} - u^{n}).
\end{equation}
We call this a \textit{finite difference operator}.
The statement $\delta_{t+}u^n$ should be read as \textit{the finite difference operator $\delta_{t+}$ applied to $u$ at time step $n$.}
We will introduce the other operators we need as we go along.

In the following sections we will also encounter distributed systems which are defined by functions like $u(x, t)$ and $u(x, y, t)$, where $x$ and $y$ are spatial coordinates.
For these we can approximate their spatial derivatives by introducing e.g. a variable $h$ so we can write $u^n_l = u(lh, nk)$ or $h_x$ and $h_y$ to write $u^n_{l, m} = u(lh_x, mh_y, nk)$. For simplicity we will often choose $h_x = h_y$.
Now, if we want to calculate the approximated derivative of, say $u(x, t)$ with respect to $x$, we would write
\begin{equation}
  \delta_{x+} u^n_l = \frac{1}{h} (u^n_{l+1} - u^n_{l}).
\end{equation}
A thorough introduction to FDSs can be found in \cite{bilbao_numerical_2009}, which was also the source for the theory presented here and the FDS-related theory of the following sections.

\section{Models of the Elements of the Yaybahar}
\label{sec:elements}

In this section we will go through each element of the Yaybahar individually: the string, springs, drum heads, the bow, and the connections between those, and cover their physics and how to simulate them using FDSs.
A block diagram of the Yaybahar model can be viewed in Figure \ref{fig:blockDiagram}.
An overview of all parameters (and their units) used for the models presented in this section is given in Table \ref{table:stringParamters}.

\begin{figure}[h]
  \centering
    \begin{tikzpicture}[
        node distance=1cm,
        roundnode/.style={circle, draw=green!60, fill=green!5, very thick, minimum size=7mm},
        squarednode/.style={rectangle, draw=red!60, fill=red!5, very thick, minimum size=5mm},
        block/.style={rectangle, draw=black!100, thick, minimum size=5mm},
        connect/.style={
           <->,
           thick,
           shorten <=2pt,
           shorten >=2pt,},
        excite/.style={
           ->,
           dotted,
           thick,
           shorten <=2pt,
           shorten >=2pt,},
        ]
        
        \node[block]    (bow)                       {Bow};
        \node[block]    (string)    [right=of bow]  {String};
        \node[block]    (spring1)   [above right=of string]  {Spring};
        \node[block]    (spring2)   [below right=of string]  {Spring};
        \node[block]    (mem1)      [right=of spring1]       {Membrane};
        \node[block]    (mem2)      [right=of spring2]       {Membrane};
        
        %Lines
        \draw[excite] (bow.east) -- (string.west);
        \draw[connect] (string.east) .. controls +(right:7mm) and +(left:7mm) .. (spring1.west);
        \draw[connect] (string.east) .. controls +(right:7mm) and +(left:7mm) .. (spring2.west);
        \draw[connect] (spring1.east) .. controls +(right:7mm) and +(left:7mm) .. (mem1.west);
        \draw[connect] (spring2.east) .. controls +(right:7mm) and +(left:7mm) .. (mem2.west);
    \end{tikzpicture}
    
    \begin{tikzpicture}[
        node distance=0.5cm,
        block/.style={rectangle, draw=black!100, thick, minimum size=5mm},
        connect/.style={
           <->,
           thick,
           shorten <=2pt,
           shorten >=2pt,},
        excite/.style={
           ->,
           dotted,
           thick,
           shorten <=2pt,
           shorten >=2pt,},
        ]
        
    \node   (root) {};
    \node   (a) [below=1.0cm of root] {};
    \node   (b) [right=of a]    {};
    \node   (c) [right=of b]    {};
    
    \node   (d) [right=2cm of c]    {};
    \node   (e) [right=of d]    {};
    \node   (f) [right=of e]    {};
    
    \node   (excitation)    [above=0.0cm of b]    {Excitation};
    \node   (connection)    [above=0.0cm of e]    {Connection};
    
    \draw[excite] (a.east) -- (c.west);
    \draw[connect] (d.east) -- (f.west);
        
    \end{tikzpicture}

  \caption{Block diagram of the Yaybahar. A bowed string is connected to two springs that connect to two drum heads.}
  \label{fig:blockDiagram}
\end{figure}

\subsection{String}
\label{sec:string}

\begin{table}[h]
\centering
\begin{tabularx}{\linewidth}{c | l | c}
  Parameter & Description & Unit \\
  \hline
  $u$ & Displacement & m \\
  $\rho$ & Material density & kg$\cdot$m$^{-3}$ \\
  $T_0$ & Tension & N \\
  $E$ & Young's modulus & Pa \\
  $A$ & Area & m$^2$ \\
  $L$ & Length & m \\
  $I$ & Area moment of inertia & m$^4$\\
  $\sigma_0$ & Freq. independent damping & s$^{-1}$\\
  $\sigma_1$ & Freq. dependent damping & m$^2 \cdot$s$^{-1}$ \\
  $\kappa$ & Spring dispersion parameter & m$^4\cdot$s$^{-2}$\\
  $M$ & Mass & kg \\
  $\mu$ & Linear density & kg$\cdot$m$^{-1}$ \\
  $H$ & Membrane thickness & m \\
  $v_\text{b}$ & Bow speed & m$\cdot$s$^{-1}$ \\
  $K$ & Spring constant & kg$\cdot$s$^{-2}$
\end{tabularx}
\label{table:stringParamters}
\caption{Table of the parameters of the elements of the Yaybahar.}
\end{table}

To model the string of the Yaybahar we will use the equations found in \cite[Chapters~6,7, and 8] {bilbao_numerical_2009}, \cite{bilbao_modular_2009}, and \cite{bensa_simulation_2003}.
A nonlinear damped stiff string with externally supplied forces is defined by the partial differential equation
\begin{align}
  \begin{split}
  u_{tt} &= \frac{1}{\rho A} \left(T_0 + \frac{E A}{2L} \int_0^L u_x^2 dx \right)u_{xx} - \frac{E I}{\rho A} u_{xxxx}\\
  &- 2 \sigma_0 u_t + 2 \sigma_1 u_{txx} + \frac{1}{\rho A}\sum_f\delta(x-x_f)F_f\ ,
  \end{split}
  \label{eq:stiffNonlinearString}
\end{align}
where $u = u(x, t)$ is the displacement of the string at point $x$ and time $t$, $\rho$ is the material density, $A$ is the cross sectional area, $T_0$ is the tension, $E$ is the Young's modulus, $L$ is the length, $I$ is the area moment of inertia, $\sigma_0$ is the frequency dependent damping, $\sigma_1$ is the frequency independent damping, and $F_f$ are external forces localized at positions $x_f$ along the string using spatial Dirac delta function $\delta(x-x_f)$.


\noindent The subscript notation, e.g. $u_{tt}$, is a shorthand for writing derivatives and should be interpreted as
\begin{equation}
  u_{tt} = \frac{\partial^2u}{\partial t^2}.
\end{equation}
%
Before proceeding with the discretization of Equation (\ref{eq:stiffNonlinearString}), let's understand what it actually says.
It all begins with Newton's second law of motion acting on an infinitesimally small section of the string
\begin{equation}
  F = \rho A a \quad \Rightarrow \quad a = \frac{F}{\rho A},
\end{equation}
which says that the acceleration $a$ of an object equals the forces $F$ applied to it divided by its mass, which for our tiny segment is $\rho A$.
This produces $u_{tt}$, the acceleration of a point on our string on the left side of the equation.
All the terms on the right hand side are the forces acting on our string.

The first term is the force that arises due to the tension of the string.
We see that this force is determined by $u_{xx}$, the curvature of the string, a result that is arrived at by analysing the tension forces acting on an infinitesimally small section of the string, see e.g. \cite[Chapter~2]{fletcher_physics_1998} or \cite[Chapter~6]{bilbao_numerical_2009}.

We can understand what this means by looking at Figure \ref{fig:diffplot}, where the solid line is the displacement of the string and $u_{xx}$ is indicated with the dashed line.
Notice that $u_{xx}$ is somewhat opposite of $u$, meaning that the string will be pulled towards the middle, its state of rest, as one would expect.

\begin{figure}[h]
  \includegraphics[width=\linewidth]{diffplot.eps}
  \label{fig:diffplot}
  \caption{Plot of a part of a string $u = u(x,t)$ (solid line) , its second derivative $u_{xx}$ (dashed line), which determines the force due to tension, and $u_{xxxx}$ (dotted line), which determines the force due to stiffness. $u_{xx}$ and $u_{xxxx}$ has been scaled for them to fit in the plot.}
\end{figure}

\noindent The multiplicative term $T_0 + \frac{E A}{2L} \int_0^L u_x^2 dx$ involves the tension $T_0$ and a higher tension will clearly result in a stronger restoring force.
The integral part can be interpreted as the increase in tension that arises due the the increased length of the string at large displacements\cite[Chapter~5]{fletcher_physics_1998}.
This give rises to phenomena such as downwards pitch glides which can be experienced by strongly plucking, for example, a guitar string.

The next term is the one involving $u_{xxxx}$, which is an expression of the force due to the stiffness of the string material.
A derivation of this can be found in \cite[Chapter~2]{fletcher_physics_1998}.
Looking at Figure \ref{fig:diffplot} we see that $u_{xxxx}$ points in the same direction as $u$. The minus sign in front of the term in equation (\ref{eq:stiffNonlinearString}) means that the stiffness will somewhat counteract the displacement of the string (but not in the same way as the tension).
Stiffness causes dispersion which gives rise to inharmonic overtones, which can be observed in, for example, a low frequency piano string or metal rods.

The term $-2 \sigma_0 u_t$ causes damping of the system that, greatly simplified, occurs due to viscous air flow, internal friction, and radiated energy\cite[Chapter~2]{fletcher_physics_1998}. 
$u_t$ is the velocity of $u$, and is a vector pointing in the direction that $u$ is currently moving. Thus, adding a force opposite of this will intuitively cause damping.
Higher velocities will cause a stronger damping force which results in a exponential decrease in volume over time.

The term $2 \sigma_1 u_{txx}$ causes frequency dependent damping of the string.
Intuitively we expect $u_{xx}$ to be larger when the string is vibrating at higher frequencies and thus cause a stronger damping.
The physical justification for this term is weak, but causes the correct perceptual phenomena of higher frequencies dying out more quickly\cite{bensa_simulation_2003}.

Proceeding with the discretization of Equation (\ref{eq:stiffNonlinearString}), we replace the derivative operators with suitable finite difference operators to get
\begin{align}
  \begin{split}
    \delta_{tt} u^n_l &= \frac{1}{\rho A} \left(T_0 + \sum^{i-1}_{i=0} (\delta_{x+} u^n_i)^2 \right)\delta_{xx}u^n_l - \frac{E I}{\rho A} \delta_{xxxx} u^n_l\\
    &- 2 \sigma_0 \delta_{t\cdot} u^n_l + 2 \sigma_1 \delta_{t-} \delta_{xx}u^n_l + \frac{1}{\rho A} \sum_fJ_l(x_f)F_f,
  \end{split}
\end{align}
where $J_l(x_f)$, the discrete counterpart of $\delta(x-x_f)$, is a spreading operator scaling $F_f$ by $1/h$ whenever $\lfloor x_f / h \rfloor = l$ and by $0$ otherwise \cite[Chapter 5]{bilbao_numerical_2009}.

The new finite difference operators are defined as
% at(l+2) - 4 * at(l+1) + 6 * at(l) - 4 * at(l-1) + at(l-2)
\begin{align}
  \delta_{tt}u^n_l &= \frac{1}{k^2}(u^{n-1}_l - 2 u^n_l + u^{n+1}_l) \\
  \delta_{xx}u^n_l &= \frac{1}{h^2}(u^n_{l-1} - 2 u^n_l + u^n_{l+1}),
\end{align}
which approximate $u_{tt}$ and $u_{xx}$,
\begin{align}
  \delta_{xxxx}u^n_l = \frac{1}{h^2}(u^n_{l-2} - 4 u^n_{l-1} + 6 u^n_l - 4 u^n_{l+1} + u^n_{l+2})
\end{align}
which approxmiates $u_{xxxx}$, and
\begin{align}
  \delta_{t\cdot}u^n_l &= \frac{1}{2k} (u^{n+1}_l - u^{n-1}_l) \\
  \delta_{t-}u^n_l &=\frac{1}{k} (u^{n}_l - u^{n-1}_l)
\end{align}
which are both approximations of $u_t\ $. $\delta_{t\cdot}$ is more accurate than $\delta_{t-}$ but can result in implicit schemes because of the dependency on $u_l^{n+1}$, therefore we sometimes use $\delta_{t-}$ instead. Alternatively, implicit schemes can be solved by iterative methods, like we do in Section \ref{sec:bow}.

To compute the solution of our string model we must derive an \textit{update rule} or \textit{recurrence equation}, which will allow us to compute the state at the next time step $u^{n+1}_l$ from the current and past states.
We do this by expanding all operators that contain $u^{n+1}_l$ and then proceed isolate $u^{n+1}_l$ to get
\begin{align}
  \label{eq:stringUpdate}
  u^{n+1}_l &= \frac{1}{1 + k\sigma_0} (F_\text{t} + F_\text{s} + F_\text{d} + F_\text{e} + 2u^n_l - u^{n-1}_l)
\end{align}
where
\begin{align}
  F_\text{t} &= \frac{k^2}{\rho A} \left(T_0 + \sum^{N-1}_{i=0} h(\delta_{x+} u^n_i)^2 \right)\delta_{xx}u_l^n \\
  F_\text{s} &= -\frac{k^2 E I}{\rho A} \delta_{xxxx} u^n_l\\
  F_\text{d} &= k\sigma_0u^{n-1}_l + 2k\sigma_1 (\delta_{xx}u^n_l - \delta_{xx}u^{n-1}_l)\\
  F_\text{e} &= \frac{k^2}{\rho A}\sum_fJ_l(x_f)F_f.
\end{align}
Notice that we did not expand the spatial difference operators because they have no influence on the isolation of $u^{n+1}_l$.
% One could perhaps expand them and reduce the above equation to fewer operations, but I tend to prefer clarity over brevity.

For implementation purposes we will need to bound the domain of our string, by choosing an integer $N$ to be the number of points on our string, evenly spaced by $h$.
Assuming that the length of our string is $L = 1$ we have $N = 1 / h$.

Special care needs to be taken at the boundaries --- the points $l=0$ and $l=N-1$.
There are multiple ways of doing this depending on what behavior we want.
We will use a clamped boundary condition, which means that the points at each end must satisfy\cite[Chapter~7]{bilbao_numerical_2009}
\begin{equation}
\label{eq:clampedBoundary}
  u = u_x = 0,
\end{equation}
which can be implemented by introducing \textit{virtual points} at positions $-2, -1, N$ and $N+1$.

To implement $u = 0$ in Equation \eqref{eq:clampedBoundary} we set the virtual points
\begin{equation}
  u_{-1} = u_{N} = 0.
\end{equation}
To implement $u_x = 0$ on the left of the string we apply $\delta_{t\cdot}$ at $l = -1$ to get
\begin{equation}
  \delta_{t\cdot} u^n_{-1} = \frac{1}{2h}(u^n_0 - u^n_{-2}) = 0,
\end{equation}
which means that setting the virtual point
\begin{equation}
  u^n_{-2} = u^n_0,
\end{equation}
will satisfy the condition.
The same is done for the right side which gives us $u^n_{N+1} = u^n_{N-1}$.

% u_{tt} &= \frac{1}{M} \left(T_0 + \frac{E A}{2L} \int u_x^2 dx \right)u_{xx} - \frac{E I}{M} u_{xxxx}\\
%   &- 2 \sigma_0 u_t + 2 \sigma_1 u_{txx} + \frac{1}{M} F

\subsection{Spring}
\label{sec:spring}

The springs which connect the string to the drum membranes are modeled using the following equation\cite{parker_modeling_2010}
\begin{align}
  \begin{split}
  u_{tt} &= -\kappa^2 u_{xxxx}- 2 \sigma_0 u_t + 2 \sigma_1 u_{txx} \\
  & + \frac{1}{\mu}\sum_f\delta(x-x_f)F_f\ .
  \end{split}
  \label{eq:spring}
\end{align}
In this model $\kappa$ is a constant usually determined by scale, Young's modulus and moment of inertia of the material, however we will use it as a dimensionless free parameter that determines the dispersive behaviour of the spring \cite{bilbao_modular_2009}\cite{parker_modeling_2010}. $\mu = L / M$ is the linear density of the spring where $L$ is the length and $M$ the total mass of the spring.
%$M$ is the mass of the spring, which we in this case can choose independently of $\kappa$.

The informed reader will notice that Equation (\ref{eq:spring}) is actually the equation for the dynamics of a linear stiff bar\cite{bilbao_modular_2009}\cite[Chapter~7]{bilbao_numerical_2009}.
However, it was also used by Parker, Penttinen, and Bilbao to model wave propagation on a slinky --- a long, large diameter spring --- so it should be suitable for modeling the springs of the Yaybahar as well\cite{parker_modeling_2010}.
Other more accurate models of springs have been developed, see e.g. \cite{parker_spring_2009}, but the one used here has the benefit of simplicity and ease of implementation for real-time purposes.

There is no need to go over the terms of Equation (\ref{eq:spring}), because we have already seen all the terms before in Equation (\ref{eq:stiffNonlinearString}) and explained them in Section \ref{sec:string}.
We should note though that there is no force due to tension, because the only restoring force in the spring is the material stiffness.

We discretize Equation (\ref{eq:spring}) by applying the suitable difference operators to get
\begin{equation}
  \begin{split}
  \delta_{tt} u^n_l &= -\kappa^2 \delta_{xxxx} u^n_l- 2 \sigma_0 \delta_{t\cdot} u^n_l + 2 \sigma_1 \delta_{t-} \delta_{xx}u^n_l\\
  & + \frac{1}{\mu} \sum_f J_l(x_f) F_f\ .
  \end{split}
\end{equation}
Then, expanding the operators and isolating $u^{n+1}_l$ we get
\begin{equation}
u^{n+1}_l = \frac{1}{1 + k\sigma_0} (F_\text{s} + F_\text{d} + F_\text{e} + 2u^n_l - u^{n-1}_l)
\end{equation}
where
\begin{align}
  F_\text{s} &= -k^2 \kappa^2 \delta_{xxxx} u^n_l\\
  F_\text{d} &= k\sigma_0u^{n-1}_l + 2k\sigma_1 (\delta_{xx}u^n_l - \delta_{xx}u^{n-1}_l)\\
  F_\text{e} &= \frac{k^2}{\mu} \sum_f J_l(x_f)F_f.
\end{align}
%
At each end, a spring is attached either to the string or to a drum head.
We will model this by using free boundary conditions and the connections covered in Section \ref{sec:connections}.
Free boundary conditions mean that at either end of the spring we must satisfy \cite{bilbao_numerical_2009}
\begin{equation}
  \label{eq:freeBoundaryCondition}
  u_{xx} = u_{xxx} = 0.
\end{equation}
%
This is implemented by first discretizing Equation (\ref{eq:freeBoundaryCondition}) using finite difference operators to get
\begin{equation}
  \label{eq:discretizedFreeBoundaryCondition}
  \delta_{xx} u^n_l = \delta_{x-}\delta_{xx} u^n_l = 0.
\end{equation}
%
If we expand Equation (\ref{eq:discretizedFreeBoundaryCondition}) for $l = 0$ we get
\begin{align}
  \frac{1}{h^2} (u^n_{-1} - 2 u^{n}_0 + u^{1}) &= 0 \label{eq:freeBoundaryDxx}\\
  \frac{1}{h^3} (-u^n_{-2} + 3u^n_{l-1} - 3u^n_0 - u^n_{1}) &= 0 \label{eq:freeBoundaryDxxxx}.
\end{align}
we then take Equation (\ref{eq:freeBoundaryDxx}) and solve for the first virtual point $u^n_{-1}$ to get
\begin{equation}
  u^n_{-1} = 2 u^n_0 - u^n_1.
\end{equation}
This can then be inserted into Equation (\ref{eq:freeBoundaryDxxxx}) so we can solve for $u^n_{-2}$ which yields
\begin{equation}
  u^n_{-2} = 3 u^n_0 - 2u^n_1.
\end{equation}
%
We can do the same exercise for the right side to get
\begin{align}
  u^n_{N} &= 2 u^n_{N-1} - u^n_{N-2}\\
  u^n_{N+1} &= 3 u^n_{N-1} - 2 u^n_{N-2},
\end{align}
where $N$ is the number of points on our spring.


\subsection{Membrane}
\label{sec:membrane}
The drum heads of the Yaybahar can be modeled as two membranes under tension.
The equation for this is built from the 2D wave equation with added damping and a nonlinearity in the tension term based on the Berger plate model\cite[Chapter~11 and 13]{bilbao_numerical_2009}
\begin{align}
  \label{eq:nonlinearMembrane}
  \begin{split}
  u_{tt} &= \frac{1}{\rho H} \left(T_0 + \frac{6D}{A H^2} \iint_\mathcal{D} (\nabla u)^2 dxdy \right)\Delta u \\
  &- 2 \sigma_0 u_t + 2 \sigma_1 \Delta u_t \\
  &+ \frac{1}{\rho H}\sum_f \delta(x-x_f, y-y_f) F_f\ .
  \end{split}
\end{align}
where we have the displacement $u = u(x, y, t)$; $H$ is the thickness of the material, $A$ is the surface area, and $\delta(x-x_f,y-y_f)$ is the (2D) spatial Dirac delta function localizing force $F_f$ at coordinate $(x_f,y_f)$. Furthermore, $\mathcal{D} \in [0,L_x]\times[0,L_y]$ describes the domain of the membrane with membrane width $L_x$ and height $L_y$. The parameter $D$ is defined by
\begin{align}
  D = \frac{E H^3}{12 (1 - \nu^2)},
\end{align}
which is the \textit{flextural regidity} of the membrane. Again, $E$ is the Young's modulus of the material and $\nu$ is Poisson's ratio, which determines how the material deforms under strain.

Notice that Equation (\ref{eq:nonlinearMembrane}) is very similar to (\ref{eq:stiffNonlinearString}) except now in two dimensions.
In fact, the forces in both equation arise due to the same phenomena.
Notice also that our membrane has no stiffness.
This is because we assume that it is made from some non-stiff material such as hide or plastic.

Because we are now working with a 2D system we need to be aware of spatial derivatives in two directions.
This is why we have the gradient, defined as
\begin{equation}
  \nabla u = u_x + u_y,
\end{equation}
and the Laplacian, defined as
\begin{equation}
  \Delta u = u_{xx} + u_{yy}.
\end{equation}
At this point we are assuming cartesian coordinates, however, since the drum heads of the Yaybahar are round, we might also want to make the domain of our model circular.
This can be done by expressing positions radial coordinates, radius $r$ and angle $\theta$, instead of $x$ and $y$.
By expressing our cartesian coordinates using our radial ones
\begin{align}
  x &= r \cos \theta\\
  y &= r \sin \theta,
\end{align}
we can transform our derivatives into radial coordinates as well, i.e., we can show that the Laplacian in radial coordinates is
\begin{equation}
  \Delta u = u_{rr} + \frac{1}{r} u_{rr} + \frac{1}{r^2} u_{\theta \theta}.
\end{equation}
%
However, this method has not been pursued as finite difference schemes in radial coordinates, especially the efficient, \textit{explicit} ones, have a tendency to misbehave \cite[Chapter~12]{bilbao_numerical_2009}.
The main problem in our case is that the sound will be severely band limited, which will kill the tone of our assembled Yaybahar model, so we will stay in cartesian coordinates.

Equation (\ref{eq:nonlinearMembrane}) can be discretized like this
\begin{align}
  \label{eq:nonlinearMembraneFds}
  \begin{split}
  \delta_{tt} u^n_{l, m} &= \frac{1}{\rho H} \left(T_0 + \frac{6D}{|\mathcal{D}| H^2} \sum_{l=0}^{N_x-1}\sum_{m=0}^{N_y-1} h_x h_y (\delta_\nabla u^n_{l, m})^2 \right)\\
  &\cdot\delta_\Delta u^n_{l, m}- 2 \sigma_0 \delta_{t\cdot} u^n_{l, m} + 2 \sigma_1 \delta_\Delta \delta_{t-} u^n_{l, m}\\
  &+\frac{1}{\rho H}\sum_f J_{l, m}(x_f, y_f) F_f,
  \end{split}
\end{align}
where $J_{l, m}(x_f,y_f)$ is a (2D) spreading operator that scales $F_f$ by $1/(h_x h_y)$ whenever $\lfloor x_f / h_x \rfloor = l \land \lfloor y_f / h_y \rfloor = m$ and by $0$ otherwise. $N_x = 1/h_x$ and $N_y=1/h_y$ are the number of horizontal and vertical points of the discrete membrane respectively. Lastly, we define the following
\begin{align}
  \delta_\Delta u^n_{l, m} &= \delta_{xx} u^n_{l, m} + \delta_{yy} u^n_{l, m},\\
  \delta_\nabla u^n_{l, m} &= \delta_{x+} u^n_{l, m} + \delta_{y+} u^n_{l, m}.
\end{align}
%
Expanding the operators in Equation (\ref{eq:nonlinearMembraneFds}) and solving for $u^{n+1}_{l, m}$ we get 
\begin{align}
  u^{n+1}_{l, m} = \frac{1}{1 + k\sigma_0} (F_\text{s} + F_\text{d} + F_\text{e} + 2 u^n_{l, m} - u^{n-1}_{l, m})
\end{align}
where
\begin{align}
\begin{aligned}
&F_\text{s} \\
&
\end{aligned}
&\begin{aligned}
  &= \frac{k^2}{\rho H} \left(T_0 + \frac{6D}{|\mathcal{D}| H^2} \sum_{l=0}^{N_x-1}\sum_{m=0}^{N_y-1} h_x h_y(\delta_\nabla u^n_{l, m})^2 \right)\\
  &\cdot\delta_\Delta u^n_{l, m} 
  \end{aligned}\\
  F_\text{d} &= k \sigma_0 u^{n-1}_{l, m} + 2 k \sigma_1 (\delta_\Delta u^{n}_{l, m} - \delta_\Delta u^{n-1}_{l, m}) \\
  F_\text{e} &= \frac{k^2}{\rho H}\sum_f J_{l, m}(x_\text{f}, y_\text{f}) F_f.
\end{align}
%
As for boundary conditions, we now have the four edges around our membrane we need to take care of\footnote{Even though we are using cartesian coordinates the shape of our membrane does not need to be rectangular, but for now that is what we choose it to be.}.
Like with the string we will use a clamped boundary conditions which means that we define virtual points
\begin{equation}
  u = \nabla u= 0,
\end{equation}
along all edges, that is, when $l = -1$, $l = N_x$, $m = -1$, or $m = N_y$.

\subsection{Bow}
\label{sec:bow}

A bow like the one used to play the Yaybahar excites the instrument through the frictional interaction between the bow hairs and the resonator being played, in this case a string.
At first, the bow pulls the string along, but at some point, the restoring force in the string becomes too large and the string bounce back only to be caught by the bow again \cite[Chapter~2]{fletcher_physics_1998}.
A simplified bow-string interaction sees the friction depending only on the relative velocity between bow and string.

We model this by using the simple simulation from \cite[Chapter~4]{bilbao_numerical_2009}, where we apply a force $F$ to our system in Equation (\ref{eq:stiffNonlinearString}) that is determined by
\begin{equation}
  \label{eq:bowForce}
  F = - F_\text{b} \phi(v_\text{rel}),
\end{equation}
where
\begin{equation}
  v_\text{rel} = u_t - v_\text{b}.
\end{equation}
Here $F_\text{b} = F_\text{b}(t)$ is the force in Newtons at which the bow is pressed down onto the string, $v_\text{rel} = v_\text{rel}(t)$ is the relative velocity between the bow and the string at the bowing point with $v_\text{b} = v_\text{b}(t)$ being the bow velocity in m/s.

There are many ways of defining the dimensionless friction characteristic $\phi$, but we will be using the definition
\begin{equation}
  \label{eq:phi}
  \phi(v_\text{rel}) = \sqrt{2a} v_\text{rel} e^{-a v_\text{rel}^2 + 1/2},
\end{equation}
where $a$ is a dimensionless constant that determines the shape of the function.
A plot of $\phi(v_\text{rel})$ can be seen in Figure \ref{fig:bowplot}.

\begin{figure}[h]
  \includegraphics[width=\linewidth]{bowplot.eps}
  \label{fig:bowplot}
  \caption{A plot of $\phi(v_\text{rel})$ in Equation (\ref{eq:phi}) with $a = 20$.}
\end{figure}
%
\noindent To implement our bow model we must discretize Equation (\ref{eq:bowForce}), which means discretizing $v_\text{rel}$.
We will do this using the scheme
\begin{equation}
  \label{eq:vrelScheme}
  v_\text{rel}^n = \delta_{t\cdot} u^n_{l_\text{b}} - v_\text{b}^n,
\end{equation}
where $l_\text{b}$ is the index of our bowing point.

If we expand Equation (\ref{eq:vrelScheme}) we get
\begin{equation}
  \label{eq:vrelSchemeExpanded}
  v_\text{rel}^n = \frac{1}{2k}\left(u^{n+1}_{l_\text{b}} - u^{n-1}_{l_\text{b}}\right) - v_\text{b}^n.
\end{equation}
Notice that $v_\text{rel}^n$ depends on $u^{n+1}_{l_\text{b}}$, but to compute $u^{n+1}_{l_\text{b}}$ using Equation (\ref{eq:stiffNonlinearString}) combined with Equation (\ref{eq:vrelScheme}) we need $v_\text{rel}^n$.
This cyclic dependency results in what we call an \textit{implicit} scheme which we can only solve using \textit{iterative methods}.
%
One such method is the Newton-Raphson algorithm which states that  a function $f(x) = 0$, then we can find  $x$ by iteratively calculating
\begin{equation}
  x^{i+1} = x^i - \frac{f(x^i)}{f'(x^i)},
\end{equation}
with iteration number $i$ and $f'(x) = df(x)/dx$, where we keep iterating until the change between $x^{i+1}$ and $x^i$ is sufficiently small.

We apply this by first putting Equation (\ref{eq:vrelSchemeExpanded}) into the correct from
\begin{equation}
  f((v_\text{rel}^n)^i) = \frac{1}{2k} \left(u^{n+1}_{l_\text{b}} - u^{n-1}_{l_\text{b}} \right) - v_\text{b} - (v_\text{rel}^n)^i = 0.
\end{equation}
Then we substitute $u^{n+1}_{l_\text{b}}$ using Equation (\ref{eq:stringUpdate}) and take the derivative of it all with respect to $v_\text{rel}^n$ to get
\begin{equation}
  f'(v_\text{rel}^n) = - \frac{1}{2k} k^2 F_\text{b} \phi'(v_\text{rel}^n) - 1.
\end{equation}
where
% sqrt2a * (exp(-a * pow2(eta) + 0.5) - 2 * a * pow2(eta) * exp(-a * pow2(eta) + 0.5))
\begin{equation}
  \phi'(v_\text{rel}^n) = \sqrt{2 a} \left(e^{-a (v_\text{rel}^n)^2 + 1/2} - 2 a (v_\text{rel}^n)^2 e^{-a (v_\text{rel}^n)^2 + 1/2} \right).
\end{equation}
And thus, we have everything we need to iteratively compute $v_\text{rel}^n$.

Note that iterative methods can have a large impact on the efficiency of our synthesis algorithm, which is not efficient from the perspective of running in real-time.
In the current case, however,  we only need to run the solver for the bowing point $l_\text{b}$ and not for every point on our string.

\subsection{Connections}
\label{sec:connections}

To connect the elements of our Yaybahar we use a simple spring-like connection.
Assuming $u^n_{l_\text{uc}}$ is the connecting point on our string and $w^n_{l_\text{wc}}$ is the connecting point on one of the springs,
the force caused by the connection between them is defined by
\begin{equation}
  F_\text{c} = K \left(u^n_{l_\text{uc}} - w^n_{l_\text{wc}}\right),
\end{equation}
where $K$ is a positive constant determining the strength of the connection. This connection scheme represents Hooke's law, and is similar the one found in \cite{bilbao_modular_2009}, where they also include nonlinear terms.

After computing the connection force $F_\text{c}$ we simply apply it to our string and spring, but in opposite directions, so if $F_\text{c}$ is applied to the string, then $-F_\text{c}$ is applied to the spring and added to their respective $F$ (external forces) in Equations (\ref{eq:stiffNonlinearString}) and (\ref{eq:spring}).

\subsection{Stability}

A topic we have not touched upon in this paper is stability, a property that is not guaranteed for FDSs.
To ensure stability, the choice of parameters for each model must satisfy a stability condition.
The procedure is usually to choose one's desired parameters and then compute a suitable value for $h$.
For the schemes for the string and membranes, the stability condition is not known exactly, however, they should at least satisfy the stability conditions for their linear counterparts.
For the string the condition is\cite{willemsen_real-time_2019}
\begin{equation}
    h \geq \sqrt{\frac{c^2 k^2 + 4\sigma_1k + \sqrt{(c^2 k^2 + 4\sigma_1k)^2 + 16 \kappa^2 k^2}}{2}}
\end{equation}
where $c = \sqrt{T_0 / \rho A}$ and $\kappa = \sqrt{EI / \rho A}$ and for the membrane, using the membrane parameters, it is\cite[Chapter~11]{bilbao_numerical_2009}
\begin{equation}
    h \geq \sqrt{2} k \frac{T_0}{\rho H},
\end{equation}
assuming that $h = h_x = h_y$.

In both cases, it is practical to choose an $h$ slightly larger (e.g. $1.05 \cdot h$) than the one given by the stability conditions to avoid instability due to the non-linearity, and in the case of the membrane, the missing $\sigma_1$ terms.

For the spring the stability condition is exactly\cite{bilbao_modular_2009}
\begin{equation}
    h \geq \sqrt{2 k \left( \sigma_1^2 + \sqrt{\kappa^2 + \sigma_1^2} \right)}.
\end{equation}

\section{Implementation}
\label{sec:implementation}

The equations described in Section \ref{sec:elements} is implemented in C++ and the code, as well as a sound sample, is available on GitHub\footnote{\url{https://github.com/pellejuul/yaybahar}}.
This section covers how the code is structured and which optimizations were applied to make it run in real-time.

\subsection{Code Structure}

The code is structured in three layers of abstraction: domains, models, and application code.

Domains implement the low level details that are common for multiple models.
This encompasses arrays for storing model states, computation of boundary conditions, and routines for the various finite difference operators.
The following domain classes are implemented
\begin{description}
  \item[Domain1d] a 1D domain used for the string and spring models.
  \item[Domain2d] a cartesian 2D domain used for the drum membrane models. 
  \item[Domain2dRadial] a radial 2D domain used in an earlier round membrane model.
\end{description}
%
The model layer uses the domain layer to implement the models of Section \ref{sec:elements}.
Using the domain classes allows the developer to focus on the high level aspects of the model without getting bogged down by e.g. the implementation of the finite difference operators.
The model classes implemented are
\begin{description}
  \item[BowedString] the string model from Section \ref{sec:string} combined with the bow model from Section \ref{sec:bow} using Domain1d.
  \item[Connection] the connection model from Section \ref{sec:connections}.
  \item[RectMembrane] the membrane model from Section \ref{sec:membrane} using Domain2d.
  \item[Spring] the spring model of Section \ref{sec:spring}.
\end{description}
%
The application code ties all the model classes together using the connection class, provides real-time audio output, and a GUI for controlling the relevant parameters of each model.

\subsection{Optimizations}
\label{sec:optimizations}

Due to the computational complexity of the models presented it is necessary to write optimized code to accomplish real-time sound synthesis.
See \cite{webb_limits_2015} for a discussion of the complexity and implementation strategies of FDS algorithms.
The optimizations applied to our software are
\begin{enumerate}
  \item Only compute what is needed.
  \item Pre-compute as much as possible.
  \item Avoid branches in critical parts of the code.
  \item Avoid memory allocation and copying.
  \item Compile with optimizations enabled (clang flag -O3).
\end{enumerate}
%
An example of optimization 1. can be found in the BowedString class, where we only need to iteratively compute $v_\text{rel}$ at point $l_\text{b}$, not for every point along the string.
% We also avoid calling the routine for $\phi(v_\text{rel})$ unless necessary.

For optimization 2., we want to focus on constant terms that contain divisions or non-arithmetic functions, such as exponentials and square roots, since these take many clock cycles to compute.
Obvious targets for this are the term $1 / (1 + k\sigma_0)$, which appears in multiple places, and $\sqrt{2a}$ in the bow model.

The reason for optimization 3. is that branches can severely slow down our code.
Branches, such as if-statements, can cause our processor, which is doing branch prediction, to have to clear its pipeline, resulting in a delay of multiple clock cycles.
One example of this is with boundary conditions: a naive implementation could use if-statements to check if we are at the boundary, resulting in multiple branches for each point in our domain.
Instead, we can use a bit more memory and pre-compute the virtual points along the boundary, thus avoiding branches.

Heap memory allocation and deallocation, e.g. malloc, new, or free, can take an indeterminate amount of time and should be avoided in critical code (optimization 4.).
A naive implementation of e.g. the string model would have three state arrays \lstinline{u}, \lstinline{un}, and \lstinline{up} representing the current, next, and previous states. After computing \lstinline{up} using the update rule it would copy the values of the arrays like so:
\begin{lstlisting}[language=C++]
for (int i = 0; i < N; i++)
{
  up[i] = u[i];
  u[i] = un[i];
}
\end{lstlisting}
The actual implementation uses C++ references in a loop so memory copy is avoided.
The three arrays (actually domain instances) \lstinline{u}, \lstinline{un}, and \lstinline{up} are now references instead, so we can simply do
\begin{lstlisting}[language=C++]
  Domain1d &uswap = up;
  up = u;
  u = un;
  un = uswap;
\end{lstlisting}
which is nearly instant.

Lastly (optimization 5) one of course have to enable compiler optimizations, which usually cases a speedup much higher than what a programmer could expect to achieve by hand.

There are of course more optimizations that one could do\cite{webb_limits_2015}.
For example on can use C++ templates and compile time execution to help the compiler optimize the code even more.
Threading can be utilized to utilize multiple processor cores, but requires care since thread initialization and synchronization introduce some latency and complicates the code. 
One could also use vectorization which can greatly speed up the computation, but doing so will usually also decrease code clarity and portability. 

\section{Conclusion}
\label{sec:conclusion}

In this paper we have covered how to build a physical modeling sound synthesis algorithm for a specific instrument: the Yaybahar.

After a brief review of FDSs we went through each element of the instrument, a bowed string, springs, and drum membranes, discussed their physics, and showed to how implement numerical simulations of them using FDSs.

The FDSs were implemented in a C++ application structured into three layers: domains, that took care of low level details, models, which implemented the models of the elements, and application, which tied everything together in an interactive real-time fashion.

For the purpose of real-time synthesis we covered some of optimizations, most of them C++ specific, which were applied to the code.

It is our hope that this paper may inspire other people to pursue physical modeling of musical instruments using FDSs in a way that will enrich the academic community and the world of sound and music in general.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%bibliography here
{
\small
\bibliography{rsmc}
}
\end{document}
